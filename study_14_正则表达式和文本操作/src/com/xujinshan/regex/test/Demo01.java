package com.xujinshan.regex.test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 一个好用的测试正则表达式软件 ==>RegexBuddy
 * 普通字符
 * 		字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符
 * 简单的转义字符
 * 		\n		代表换行
 * 		\t		制表符
 * 		\\		代表\自身
 * 		\^,\$,\(,\),\{,\},\?,\+,\*,\|,\[,\]			匹配这些字符自身
 * 
 * 标准字符集合
 * 能够与“多种字符”匹配的表达式(注意区分大小写，大写是相反的意思)
 * 		\d		任意一个数字，0-9中的任意一个
 * 		\w		任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中的任意一个
 * 		\s		包括空格、制表符、换行符等空白字符中的其中任意一个
 * 		.		小数点可以匹配任意一个字符(除了换行符)如果要匹配包括(\n)在内的所有字符，一般使用[\s\S]
 * 
 * 自定义字符集合
 * 		[]方括号匹配方式，能够匹配方括号中任意一个字符
 * 			[ab5@]			匹配"a"或"b"或"5"或"@"
 * 			[^abc]			匹配"a","b","c"之外的任意一个字符
 * 			[f-k]			匹配"f"-"k"之间的任意一个字符
 * 			[^A-F0-3]		匹配"A"-"F","0"-"3"之外的任意一个字符
 * 			正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了"^","-"之外
 * 			标准字符集合，除小数点之外，如果被包含到中括号中，自定义字符集合将包含该集合，
 * 				[\d.\-+]将匹配：数字，小数点，-，+
 * 
 * 量词   ==>修饰匹配次数的特殊符号
 * 		{n}				表达式重复n次
 * 		{m,n}			表达式至少重复m次，至多重复n次
 * 		{m,}			表达式至少重复m次
 * 		?				匹配表达式0次或1次，相当于{0,1}
 * 		+				表达式至少出现1次，相当于{1,}
 * 		*				表达式不出现，或出现任意次，相当于{0,}
 * 		匹配次数中的贪婪模式(匹配字符越多越好，默认)
 * 		匹配次数中的非贪婪模式(匹配字符越少越好，修饰匹配次数的特殊符号后面再加一个"?"号，例如：{3,9}?)
 * 
 * 字符边界     ==> 匹配的不是字符而是位置，符合某种条件的位置
 * 		^ 				与字符串开始的地方匹配
 * 		$				与字符串结束的地方匹配
 * 		\b				匹配一个单词的边界(\b匹配这样一个位置：前面的字符和后面的字符不全是\w)
 * 
 * 正则表达式匹配模式
 * 		IGNORECASE		忽略大小写模式
 * 			匹配时忽略大小写
 * 			默认情况下，正则表达式是要区分大小写的
 * 		SINGLELINE		单行模式
 * 			整个文档看做一个字符串，只有一个开头，一个结尾
 * 			使小数点"."可以匹配包含换行符(\n)在内的任意字符
 * 		MULTILINE		多行模式
 * 			每一行都是一个字符串，都有开头和结尾
 * 			在指定了MULTILINE	后，如果需要仅匹配字符串开始和结束位置可以使用\A和\Z
 * 	选择符与分组
 * 		|				分支结构		左右俩边表达式之间“或”关系，匹配左边和右边
 * 		()				捕获组		在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
 * 									取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到
 * 									每一对括号会分配到一个编号，使用()的捕获根据左括号的顺序从1开始自动编号，捕获元素编号为0 的是整个正则表达式模式匹配的文本
 * 		(?:Expression)	非捕获组		一些表达式中，不得不使用()，但又不需要保存()中子表达式匹配的内容，这时候可以用非捕获组来抵消使用()带来的副作用
 * 反向引用(\nnn)
 * 		每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号
 * 		通过反向引用，可以对分组已捕获的字符串进行引用
 * 
 * 预搜索(零宽断言)
 * 		只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度
 * 		这个位置应该符合某个条件，判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，是对位置的匹配
 * 		正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的，
 * 		如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么认为这个子表达式是零宽度的。占有字符还是零宽度的，是针对匹配的内容是否保存到最终的匹配结果中而言的
 *		
 *		(?=exp)			断言自身出现的位置的后面能匹配表达式exp
 *		(?<=exp)		断言自身出现的位置的前面能匹配表达式exp
 *		(?!exp)			断言此位置的后面不能匹配表达式exp
 *		(?<!exp)		断言此位置的前面不能匹配表达式exp
 * @author xujinshan361@163.com
 *
 */

/**
 * 测试正则表达式对象的基本用法
 * @author xujinshan361@163.com
 *
 */
public class Demo01 {
	
	public static void main(String[] args) {
		//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+
		//表达式对象
		Pattern p = Pattern.compile("\\w+");
		//创建Matcher对象
		Matcher m = p.matcher("asfsdf2&&3323");
		boolean yesorno = m.matches();	//尝试将整个字符序列与该模式匹配
		System.out.println(yesorno);

		boolean yesorno2 = m.find();	//该方法扫描输入的序列，查找与该模式匹配的下一个子序列
		System.out.println(yesorno2);

		System.out.println(m.find());
		System.out.println(m.group());
		System.out.println(m.find());
//		System.out.println(m.group());   //找不到内容,会报错
		
	
		while(m.find()){
			System.out.println(m.group());	//group(),group(0)匹配整个表达式的子字符串
			System.out.println(m.group(0));
		}
	}
}
